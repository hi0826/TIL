# 6 컨슈머의 내부 동작 원리와 구현

## 6.1 컨슈머 오프셋 관리

- 가장 핵심 동작
- `__consumer_offsets` 토픽에 각 컨슈머 그룹별 오프셋 위치 정보 기록
  - 컨슈머 그룹, 토픽, 파티션 등의 내용을 통합해 기록
  - 오프셋 값은 컨슈머가 "다음"으로 읽어야 할 위치
  - 파티션 수 50, 리플리케이션 팩터 수 3, `servers.properties`에서 변경 가능
    - `offsets.topic.num.partitions`
    - `offsets.topic.replication.factor`

## 6.2 그룹 코디네이터

- 컨슈머 그룹 관리를 위한 별도의 코디네이터
  - 카프카 클러스터 브로커중 하나에 위치
  - 컨슈머 그룹이 최초 연결 요청시 브로커에 생성
- 컨슈머 리밸런싱
  - 컨슈머 그룹에서 각 컨슈머에 작업을 균등하게 분배
- 컨슈머 그룹이 구독한 토픽의 파티션과 멤버들을 트래킹
  - 파티션, 그룹 멤버에 변화 발생시 리밸런싱
- 컨슈머 그룹의 변화는 컨슈머가 코디네이터에 join, leave 요청을 보내면서 자연스럽게 처리
- 컨슈머 변경 감지를 위해 하트비트를 주고받음
  - `hearbeat.interval.ms` : 기본값 3000, session.timeout.ms보다 낮게 설정(1/3 권장) 인터벌 시간
  - `session.timeout.ms` : 기본값 10000, 특정시간안에 하트비트를 받지 못하면 그룹에서 컨슈머 제외, 리밸런싱
  - `max.poll.interval.ms` : 기본값 300000, 컨슈머의 주기적인 poll 요청을 기다리는 최대 시간, 해당 시간동안 poll이 일어나지 않으면 리밸런싱
- 리밸런싱은 비용이 높은 동작
  - 컨슈머 감지가 빠르면
    - 일시적인 타임아웃이나 TCP 패킷 손실로 인한 리밸런싱이 빈번하게 일어날 수 있음
  - 느리면
    - 파티션 메세지를 읽지 못하는 현상이 발생할 수 있음

## 6.3 스태틱 멤버십

- 컨슈머는 엔티티ID를 가지고 있음
  - 컨슈머 재시작시 새로운 엔티티ID를 부여하면서(새로운 멤버로 인식), 리밸런싱이 일어남
  - 스태틱 멤버십의 탄생 배경
- 컨슈머마다 인식할 수 있는 ID 부여, 기존 멤버로 인식하여 리밸런싱X
- `group.instance.id` 옵션 설정
  - 아파치 카프카 2.3 이상
  - 각 컨슈머 인스턴스별로 고유한 값
  - `session.timeout.ms`를 기본값보다 높일 것
    - 재시작 시 heartbeat timeout을 방지하기 위함

## 6.4 컨슈머 파티션 할당 전략

- 컨슈머 파티셔너
  - 대상 토픽의 어느 파티션으로부터 레코드를 읽어올지 결정
  - 리더 컨슈머가 파티션 할당 전략에 따라 컨슈머와 토픽의 파티션 매칭
- 파티션 할당 전략
  - `partition.assignment.strategy` 옵션
  - `RangeAssignor` 레인지 : 기본값, 토픽별로 할당 전략 동일한 키를 이용하는 2개이상의 토픽 컨슘시 유용
  - `RoundRobinAssignor` 라운드로빈 : 사용가능한 파티션과 컨슈머들을 라운드 로빈 방식, 균등 분배
  - `StickyAssignor` 스티키 : 컨슈머가 컨슘하고 있는 파티션을 계속 유지
  - `CooperativeStickyAssignor` 협력적 스티키 : 전체 일시 정지가 아닌 연속적인 재조정 방식

### 6.4.1 레인지 파티션 할당 전략

- 구독하는 토픽에 대한 파티션을 순서대로 나열, 컨슈머를 순서대로 정렬
- 전체 파티션 수를 컨슈머 수로 나눔
  - 일치하면 균등 할당
  - 불일치시 앞쪽의 컨슈머들은 추가 파티션 할당
- 동일한 레코드(메시지) 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할 때 유용
- 컨슈머 그룹이 불균형한 상태로 운영될 수 있음

### 6.4.2 라운드 로빈 파티션 할당 전략

- 모든 파티션과 컨슈머를 나열 후 라운드 로빈으로 하나씩 할당
- 균등하게 매핑

### 6.4.3 스티키 파티션 할당 전략

- 리밸런싱이 발생해도 기존 매핑된 파티션과 컨슈머를 유지하려고 하는 전략
- 두 가지 목적
  - 가능한 한 균형 잡힌 파티션 할당
  - 재할당 발생시 되도록 기존 할당된 파티션 정보를 보장
- 스티키 파티션 할당의 규칙
  - 컨슈머의 최대 할당된 파티션 수의 차이는 1
  - 기존 파티션 할당은 최대한 유지
  - 재할당시 유효하지 않은 파티션 할당 제거
  - 할당되지 않은 파티션은 균형을 맞춘느 방법으로 컨슈머에 할당

### 6.4.4 협력적 스티키 파티션 할당 전략

- 그룹 내부의 리밸런싱 동작이 한층 더 고도화
- 컨슈머 리밸런싱 동작시 EAGER라는 리밸런스 프로토콜 사용(내부동작)
  - 모든 할당된 파티션 할당 취소
    - 컨슈머 파티션 소유권 변경을 위함
    - 그룹 내 여러 파티션들에 대해 소유권 변경 작업 로직의 단순화를 위함
  - 감지 > 중지 > 재시작의 프로세스
    - 리밸런싱 동안 컨슈머 다운타임이 문제됨
- EAGER > COOPERATIVE 프로토콜로 변경
  - 리밸런싱이 동작하기 전 컨슈머 상태 유지
  - 동작중인 컨슈머에겐 영향이 없음
  - 몇 차례에 걸쳐 리밸런싱이 일어남
    - 감지 > 첫 번째 리밸런싱 > 두 번째 리밸런싱

## 6.5 정확히 한 번 컨슈머 동작

- 트랜잭션 코디네이터가 특수한 메시지를 표시한 레코드만 읽으면 정확히 한 번 읽기 가능
- `ISOLATION_LEVEL_CONFIG` 설정 추가시, 트랜잭션 컨슈머로 동작
  - 트랜잭션이 완료된 메시지만 읽기 가능
  - 기본값 `read_uncommitted`
  - `read_committed`로 변경시 트랜잭션이 완료된 메시지만 읽기 가능
- 실습
  - 오프셋이 하나 더 추가된 이유
    - 트랜잭션의 종료를 표시하기 위해 표시를 남기는 트랜잭션 메시지 추가 (사용자에겐 보이지 않음)
- 트랜잭션 컨슈머라고 정확히 한 번만 가져오는 것은 아님
  - 트랜잭션 컨슈머는 트랜잭션 코디네이터와 통신하는 부분이 없어, 한 번만 가져오는지는 보장할 수 없음
- 컨슈머의 동작까지 정확히 한 번 처리가 가능해지려면 `컨슘 - 메시지 처리 - 프로듀싱` 이 하나의 트랜잭션으로 처리돼야 함
  - `sendOffsetsToTransaction` 메소드를 이용하여 컨슈머 그룹의 오프셋 컴시을 트랜잭션에 포함
- 카프카 커넥터중 HDFS 커넥터는 정확히 한 번 HDFS에 저장되도록 지원하므로 확인해 볼 것
