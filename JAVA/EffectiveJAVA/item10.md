# equals는 일반 규약을 지켜 재정의하라

- equals를 재정의 하기 전에 체크해야할 사항 (하나라도 해당이된다면 재정의하지 않는 것이 최선)
  - 각 인스턴스가 본질적으로 고유하다
  - 인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없다
  - 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다
  - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다
- equals 메서드를 재정의 할 때는 반드시 일반 규약을 따라야함
  - equals 메서드는 동치관계를 구현하며, 다음을 만족한다
  - 반사성 : null이 아닌 모든 참조 값 x에 대해 x.equals(x) = true
  - 대칭성 : null이 아닌 모든 참조 값 x, y에 대해 x.equals(y) = true, y.equals(x) = true
  - 추이성 : null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y) = true, y.equals(z) = true, x.equals(z) = true
  - 일관성 : null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 같은 결과가 나와야 한다
  - notNull : null이 아닌 모든 참조 값 x에 대해 x.euqlas(null) = false
- 반사성
  - 단순히 객체는 자기 자신과 같아야 함
- 대칭성
  - 두 객체는 서로에 대한 동치성 여부에 똑같이 답해야 한다.
  - equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다
- 추이성
  - `A = B, B = C, A = C`
  - 삼단논법
  - 구체 클래스를 확장해 새롱누 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않음
- 일관성
  - 두 객체가 같고 수정되지 않는다면, 영원히 같아야 함
  - equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서 안 됨

## 양질의 equals 메서드 구현 방법을 단계적으로 정리

- == 연산자를 사용해 입력이 자기 자신의 참조인지 확인
  - 자기 자신이면 true 반환, 성능 최적화용, 비교 자겅ㅂ이 복자한 상황일 때 값어치를 할 것
- instanceof 연산자로 입력이 올바른 타입인지 확인
  - 아니라면 false 반환
  - equals가 정의된 클래스인 것이 보통, 특정 인터페이스가 될 수도 있다
- 입력을 올바른 타입으로 형변환
  - instanceof 를 이전 단계에서 수행했으므로 100% 성공
- 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사
  - 모든 필드가 일치하면 true, 하나라도 다르면 false
- equals를 다 구현했다면 대칭성, 추이성, 일관성만을 비교해 보자
- equals를 재정의할 떈 hashCode도 반드시 재정의하자
- 너무 복잡하게 해결하려 들지 말자
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자
- 꼭 필요한 경우외에는 equals를 재정의 하지 말자
  - Object.equals가 대부분의 비교를 정확히 수행해준다
