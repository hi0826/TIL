# 변화로부터 코드를 보호하려면 추상화를 사용하라

함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있음

이후에 실질적인 코드를 원하는대로 수정이 가능하다 > 함수를 사용하는 쪽은 함수의 입출력만 알면 된다

## 상수

리터럴을 상수 프로퍼티로 변경하면, 상수 값 변경 시 훨씬 쉽게 변경할 수 있음

## 함수

많이 사용되는 알고리즘은 간단한 확장 함수로 만들어서 사용 가능

함수 내부의 내용이 바뀔 때 이름도 변경하면 된다 > 이름을 직접 바꾸는 것은 좋지 않다 (Item 28)

다른 모듈이 함수를 사용할 경우 이름을 직접 변경하면 영향이 생기므로 계층을 분리해서 사용하자

## 클래스

클래스가 함수보다 더 강력한 이유는 상태를 가질 수 있으며, 많은 수의 함수를 가질 수 있기 때문

클래스는 더 많은 자유를 주지만, 한계가 있음

- 클래스가 final일 경우, 해당 클래스 타입 아래에 어떤 구현이 있는지 알 수 있음
- open 클래스를 활용하면 조금 더 큰 자유를 얻을 수 있음 > 서브 클래스를 대신 제공할 수 있기 때문
- 더 큰 자유를 얻으려면 더 추상적이게 만들면 된다

## 인터페이스

보통 라이브러리를 만들 때, 내부 클래스의 가시성을 제한하고, 인터페이스를 통해 노출 시킨다

인터페이스 뒤에 객체를 숨김으로써 실직적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있다 > 커플링 줄이기

코틀린이 인터페이스를 자주 사용하는 것은 멀티 플랫폼 언어이기 때문

테스트 시 인터페이스 페이킹(faking)이 클래스 모킹보다 간단하므로, 모킹라이브러리를 사용하지 않아도 된다
`val messageDisplay: MessageDisplay = TestMessageDisplay()`

## 추상화가 주는 자유

### 추상화 방법

- 상수로 추출
- 동작을 함수로 래핑
- 함수를 클래스로 래핑
- 인터페이스 뒤에 클래스 숨기기
- 보편적인 객체를 특수한 객체로 래핑

### 구현시 사용하는 도구

- 제네릭 타입 파라미터를 사용한다
- 내부 클래스를 추출한다
- 생성을 제한한다(ex. 팩토리 메서드)

## 추상화의 문제

추상화 시에는 코드를 읽는 사람이 해당 개념을 배우고 잘 이해해야 한다

추상화의 가시성을 제한하거나(item 30), 구체적인 작업에만 추상화를 도입하는 것은 큰 문제가 없음 > 큰 프로젝트에서는 잘 모듈화 해야 한다

추상화의 비용도 발생하기 때문에 극단적으로 모든 것을 추상화해서는 안됨

추상화는 많은 것을 숨길 수 있는 테크닉, 생각한 것을 어느 정도 숨겨야 개발이 쉬워지지만, 너무 많은 것을 숨기면 이해가 어려워진다

## 어떻게 균형을 맞춰야 할까??

추상화의 균형을 맞추는 것에 영향을 주는 요소

- 팀의 크기
- 팀의 경험
- 프로젝트의 크기
- 특징 세트
- 도메인 지식

### 사용 가능한 몇 가지 규칙

- 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어려움. 추상화 방법을 사용하는 것이 좋다. 최대한 모듈과 부분을 분리하기
- 의존성 주입 프레임워크를 사용하기
- 테스트를 하거나, 다른 애플리케이션 기반 새로운 애플리케이션을 만든다면, 추상화를 사용하는 것이 좋다
- 프로젝트가 작고 실험적이라면 추상화 없이 직접 변경해도 괜찮다.

항상 무언가 변화할 수 있다는 것을 가정하기

## 정리

추상화는 단순하게 중복성을 제거해서 코드를 구성하기 위한 것이 아님, 코드를 변경해야할 때 도움이 된다

추상화를 사용하는 것은 어렵지만 배우고 이해할 것

추상적인 구조를 사용함녀 결과 이해가 어렵다

장/단점을 모두 이해하고, 프로젝트 내에서 균형을 찾아야 한다

너무 많거나 적은 상황 모두 좋은 상황이 아님
