# 적절하게 null을 처리하라

- null은 최대한 명확한 의미를 갖는 것이 좋음 > Nullable을 처리하기 위함
- nullable을 처리하는 세 가지 방법
  - ?., 스마트 캐스팅, ?: 연산자등을 활용해서 안전하게 처리
  - 예외 throw
  - 함수, 프로퍼티를 리팩터링하여 nullable이 나오지 않게

## null을 안전하게 처리하기

safe call과 스마트 캐스팅

- 가장 편리하여 많이 활용됨

Elvis 연산자 활용하기

- Elvis는 return 과 throw를 포하한 모든 표현식 허용

스마트 캐스팅은 코틀린 규약기능을 지원

## 방어적 프로그래밍과 공격적 프로그래밍

- 프로그램을 방어해서 안정성을 높이는 방법, 상황을 처리할 수 있는 올바른 방법이 있을 때는 굉장히 좋음
- 예상치 못한 상황이 발생했을 때, 개발자에게 알려서 수정하게 만드는 것은 공격적 프로그래밍 > require, check, assert

## 오류 throw 하기

- 오류를 강제로 발생시킬 때는 throw, !!, requireNotNull, checkNotNull 사용하기

## not-null assertion(!!)과 관련된 문제

- NPE발생 우려, 제네릭 예외(어떤 설명도 없는)가 발생한다
- nullable이지만, null이 나오지 않는다는 것이 거의 확실한 상황에서 사용됨
- 명시적 오류는 제네릭 NPE보다 훨씬 더 많은 정보를 제공해 줄 수 있으므로 !! 사용보다는 나음
- nullability가 제대로 표현되지 않는 라이브러리를 사용할 때 정도에만 사용할 것
- 일반적으로 !! 연산자 사용을 피하자

## 의미없는 nullability 피하기

- nullability는 어떻게든 처리해야하므로 추가 비용이 발생, 따라서 피하는게 좋음
- 어떤 값이 클래스 생성 이후 확실하게 설정된다는 보장이 있으면 lateinit와 notNull 델리게이트 사용
- 빈 컬렉션 리턴
- None enum 사용 > 정의에 없으므로 필요한 경우에 사용하는 쪽에서 추가하여 활용할 수 있음

## lateinit 프로퍼티와 notNull 델리게이트

- !! 연산자로 언팩하지 않아도 된다
- 이후에 어떤 의미를 나타내기 위해서 null을 사용하고 싶을 때 nullable로 만들 수 있다
- 프로퍼티가 초기화 된 이후에는 초기화되지 않은 상태로 돌아갈 수 없다
- 프로퍼티를 처음 사용하기 전에 반드시 초기화될 거라고 예상되는 상황에 활용하기
- lateinit을 사용할 수 없는 경우에는 Delegates.notNull을 사용할 것
- 프로퍼티 위임을 사용하여(item21) nullability로 발생하는 여럭가지 문제를 안전하게 처리할 수 있음
