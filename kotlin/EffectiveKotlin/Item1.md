# 가변성을 제한하라

1. 상태변경이 많아지면 코드 추적이 어려워짐
2. 가변성은 코드의 추론이 어려워짐
3. 멀티스레드일 경우 동기화가 필요 > 변경이 일어나는 모든 부분에서 충돌발생 가능
4. 더 많은 조합의 테스트를 해봐야 함
5. 상태 변경이 일어날 경우 다른 부분에 알려야 함 > 리스트가 변경될 때 마다 정렬

- 일관성이 떨어지고 복잡성이 증가한다

## 코틀린에서 가변성 제한하기

1. val
2. 가변 컬렉션 / 읽기 전용 컬렉션 구분
3. 데이터 클래스의 copy

### val

- val을 사용한다고해도 mutable한 객체를 다룬다면 내부적으로 변경가능성이 있다
- 게터만 제공, var로 오버라이드해서 사용
- val은 immutable은 아니다, 읽기전용, 게터와 델리게이트로 정의
- 변경이 필요없다면 final 사용
- 스마트 캐스트와 같은 추가적 기능 사용 가능

### 가변 컬렉션과 읽기 전용 컬렉션 구분

- mutable 컬렉션과 일반 컬렉션으로 구분해서 사용
- 컬렉션 다운캐스팅 금지 > 추상화 위반
- Mutable로 copy해서 사용할 것 `toMutable~` method

### 데이터 클래스의 copy

- Immutable 객체를 사용할 때의 장점
  1. 한 번 정의된 상태가 유지, 코드 이해가 용이
  2. immutable 객체는 공유했을 때도 충돌이 이루어지지 않아 안전한 병렬처리 가능
  3. 참조가 변경되지 않아 쉽게 캐시 가능
  4. defensive copy를 만들 필요가 없음, 깊은 복사를 따로 진행하지 않아도 됨
  5. 다른 객체를 만들 때 활용하기 좋음
  6. 셋, 맵의 키로 활용하기 좋음, (아이템41: 해시코드의 규약을 지켜라 참고)
- data 클래스는 copy 메서드를 만들어준다,(외 관련 메서드는 아이템 37 참고)

## 다른 종류의 변경 가능 지점

- var와 mutable 컬렉션의 차이
  - add 와 + 1은 변경 가능 지점이 다르다, add는 리스트 구현 내부에 변경 가능 지점이 있어, 동기화 여부 판단이 어렵지만, +1은 그 자체가 변경 지점이므로 멀티스레드 처리 안정성이 높아진다
  - mutable의 경우 사용자 정의 세터나 델리게이터를 사용해 변경추적이 가능
  - 프로퍼티와 컬렉션 모두 mutable 하게 사용하는 것은 최악 > 모두 동기화를 구현해야함

### 변경 가능 지점 노출하지 않기

- 방어적 복제 사용(리턴되는 mutable객체를 복제해서 리턴)
- 읽기 전용 컬렉션으로 업캐스트하여 리턴

## 정리

- var 보다는 val
- mutable 보다는 immutable 프로퍼티
- mutable 객체, 클래스 보다는 immutable 객체, 클래스 사용
- immutable 클래스의 변경이 필요하다면, data 클래스의 copy 활용
- 컬렉션에 상태 저장시 읽기 전용 컬렉션 사용
- 변이 지점을 적절하게 설계
- mutable 객체 외부 노출 절제(방어적 복제 사용)
- 최적화는 3부에서 설명
